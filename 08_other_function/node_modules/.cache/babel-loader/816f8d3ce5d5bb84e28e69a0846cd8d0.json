{"ast":null,"code":"// import { useState, useRef } from \"react\";\n\n// /* POINT useRefでDOMを取得\n// refオブジェクトをref属性に渡すとDOMを参照することができます。\n// */\n// const Case1 = () => {\n//   const [value, setValue] = useState(\"\");\n//   const inputRef = useRef();\n\n//   // console.log(inputRef);\n\n//   return (\n//     <div>\n//       <h3>ユースケース1</h3>\n//       <input\n//         type=\"text\"\n//         ref={inputRef}\n//         value={value}\n//         onChange={(e) => setValue(e.target.value)}\n//       />\n//       <button onClick={() => inputRef.current.focus()}>\n//         インプット要素をフォーカスする\n//       </button>\n//     </div>\n//   );\n// };\n\n// // POINT 動画の再生・停止を制御\n// const Case2 = () => {\n//   const [playing, setPlaying] = useState(false);\n//   const videoRef = useRef();\n\n//   return (\n//     <div>\n//       <h3>ユースケース2</h3>\n//       <video style={{ maxWidth: \"100%\" }} ref={videoRef}>\n//         <source src=\"./sample.mp4\"></source>\n//       </video>\n//       <button\n//         onClick={() => {\n//           if (playing) {\n//             videoRef.current.pause();\n//           } else {\n//             videoRef.current.play();\n//           }\n\n//           setPlaying((prev) => !prev);\n//         }}\n//       >\n//         {playing ? \"Stop\" : \"Play\"}\n//       </button>\n//     </div>\n//   );\n// };\n\n// const createTimeStamp = () => new Date().getTime();\n\n// /* POINT useRefは再レンダリングされません。\n// 書き換え可能な情報としてコンポーネントに保持させておくことができます。\n// state は更新されるごとに再レンダーされますが、refオブジェクトの中身が変わっても再レンダーが走ることはありません。\n// */\n// const Case3 = () => {\n//   const [timeStamp, setValue] = useState(createTimeStamp());\n//   const ref = useRef(createTimeStamp());\n\n//   const updateState = () => {\n//     setValue(createTimeStamp());\n//   };\n\n//   const updateRef = () => {\n//     /* コンソールを見るとブラウザの表示と、ref.currentの中身が異なることを確認できます */\n//     ref.current = createTimeStamp();\n//     console.log(\"ref.current -> \", ref.current);\n//   };\n//   return (\n//     <div>\n//       <h3>ユースケース3</h3>\n//       <p>\n//         state: {timeStamp}\n//         <button onClick={updateState}>更新</button>\n//       </p>\n//       <p>\n//         ref: {ref.current}\n//         <button onClick={updateRef}>更新</button>\n//       </p>\n//     </div>\n//   );\n// };\n\n// /* POINT refを使うべきタイミング\n// Reactは一般的に、propsを通して親から子へ作用させる、というデータフローが原則です。\n// refを使ってコンポーネントに作用を起こすことは、その原則を崩す行為なので多用は避けましょう。\n\n// refに適した使用例は以下の場合とされています。\n// - フォームへのフォーカス、テキストの選択、メディア（動画・音声）の再生の管理\n// - アニメーションの発火\n// - サードパーティの DOM や、React管理外のDOMの埋め込み\n// */\n// const Example = () => {\n//   return (\n//     <>\n//       <Case1 />\n//       <Case2 />\n//       <Case3 />\n//     </>\n//   );\n// };\n\n// export default Example;","map":{"version":3,"names":[],"sources":["/Users/s.kitagawa/Desktop/react-guide-material/08_other_function/src/030_useRef/end/Example.js"],"sourcesContent":["// import { useState, useRef } from \"react\";\n\n// /* POINT useRefでDOMを取得\n// refオブジェクトをref属性に渡すとDOMを参照することができます。\n// */\n// const Case1 = () => {\n//   const [value, setValue] = useState(\"\");\n//   const inputRef = useRef();\n\n//   // console.log(inputRef);\n\n//   return (\n//     <div>\n//       <h3>ユースケース1</h3>\n//       <input\n//         type=\"text\"\n//         ref={inputRef}\n//         value={value}\n//         onChange={(e) => setValue(e.target.value)}\n//       />\n//       <button onClick={() => inputRef.current.focus()}>\n//         インプット要素をフォーカスする\n//       </button>\n//     </div>\n//   );\n// };\n\n// // POINT 動画の再生・停止を制御\n// const Case2 = () => {\n//   const [playing, setPlaying] = useState(false);\n//   const videoRef = useRef();\n\n//   return (\n//     <div>\n//       <h3>ユースケース2</h3>\n//       <video style={{ maxWidth: \"100%\" }} ref={videoRef}>\n//         <source src=\"./sample.mp4\"></source>\n//       </video>\n//       <button\n//         onClick={() => {\n//           if (playing) {\n//             videoRef.current.pause();\n//           } else {\n//             videoRef.current.play();\n//           }\n\n//           setPlaying((prev) => !prev);\n//         }}\n//       >\n//         {playing ? \"Stop\" : \"Play\"}\n//       </button>\n//     </div>\n//   );\n// };\n\n// const createTimeStamp = () => new Date().getTime();\n\n// /* POINT useRefは再レンダリングされません。\n// 書き換え可能な情報としてコンポーネントに保持させておくことができます。\n// state は更新されるごとに再レンダーされますが、refオブジェクトの中身が変わっても再レンダーが走ることはありません。\n// */\n// const Case3 = () => {\n//   const [timeStamp, setValue] = useState(createTimeStamp());\n//   const ref = useRef(createTimeStamp());\n\n//   const updateState = () => {\n//     setValue(createTimeStamp());\n//   };\n\n//   const updateRef = () => {\n//     /* コンソールを見るとブラウザの表示と、ref.currentの中身が異なることを確認できます */\n//     ref.current = createTimeStamp();\n//     console.log(\"ref.current -> \", ref.current);\n//   };\n//   return (\n//     <div>\n//       <h3>ユースケース3</h3>\n//       <p>\n//         state: {timeStamp}\n//         <button onClick={updateState}>更新</button>\n//       </p>\n//       <p>\n//         ref: {ref.current}\n//         <button onClick={updateRef}>更新</button>\n//       </p>\n//     </div>\n//   );\n// };\n\n// /* POINT refを使うべきタイミング\n// Reactは一般的に、propsを通して親から子へ作用させる、というデータフローが原則です。\n// refを使ってコンポーネントに作用を起こすことは、その原則を崩す行為なので多用は避けましょう。\n\n// refに適した使用例は以下の場合とされています。\n// - フォームへのフォーカス、テキストの選択、メディア（動画・音声）の再生の管理\n// - アニメーションの発火\n// - サードパーティの DOM や、React管理外のDOMの埋め込み\n// */\n// const Example = () => {\n//   return (\n//     <>\n//       <Case1 />\n//       <Case2 />\n//       <Case3 />\n//     </>\n//   );\n// };\n\n// export default Example;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA"},"metadata":{},"sourceType":"module"}